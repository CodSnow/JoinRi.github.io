<html>
<head>
  <title>Saprk</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a href="../index.html">首页</a>
<a name="413"/>
<h1>Saprk</h1>

<div>
<span><div><div><div style="text-align: center;"><img src="Saprk_files/Image.png" type="image/png" data-filename="Image.png" width="404"/></div><div><br/></div><div><br/></div><div style="text-align: center;"><img src="Saprk_files/Image [1].png" type="image/png" data-filename="Image.png" width="421"/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><img src="Saprk_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;; font-weight: bold;">Spark</span><span style="font-size: 14pt; color: black; font-family: 华文细黑; font-weight: bold;">原理与架构</span></font></div><ul><li><div><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: &quot;FrutigerNext LT Regular&quot;;">Spark Core</span></div></li><li><div><font style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: 华文细黑;">和</span><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span></font></div></li><li><div><span style="font-size: 14pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark Structured Streaming</span></div></li><li><div><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: &quot;FrutigerNext LT Regular&quot;;">Spark Streaming</span></div></li></ul><div><font style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: &quot;FrutigerNext LT Regular&quot;;">            Spark</span><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: 华文细黑;">在</span><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: &quot;FrutigerNext LT Regular&quot;;">FusionInsight</span><span style="font-size: 14pt; color: rgb(127, 127, 127); font-family: 华文细黑;">中的集成情况</span></font></div><div>Saprk 特点（四个特点）：</div><div><br/></div><div>    轻，快，灵，巧</div><div><br/></div><div><img src="Saprk_files/Image [3].png" type="image/png" data-filename="Image.png" width="591"/></div><div><br/></div><div><br/></div><div><br/></div><div>数独案例：</div><div>  首先spark的RDD从哪里来？ 从HDFS里面来，所以我们调用textfile命令从HDFS中读出了第一个RDD，就把这些数据全部读出来， </div><div>  第二步进行flatmap，把这些数据按照分隔符 在这里也就是空格，进行分割 分割成一个个单词</div><div>   接下来进行map操作生成第三个RDD，每个单词出现一次就给他记一次数，</div><div>   然后再进行reduceByKey，对这些数进行一个统计合并，生成了第四个RDD，</div><div>   最后把生成的这个RDD存回到HDFS，执行saveAsTextFile这个命令</div><div> save之前都是Transformation算子  从save开始才是action算子</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Spark SQL</span></div><div><br/></div><div>    结构化数据处理的模块，无缝使用SQL 或DatFrame</div><div><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">   </span> <span style="font-size: 10pt; color: black;">Spark SQL</span><span style="font-size: 10pt; color: black;">将</span><span style="font-size: 10pt; color: black;">SQL</span><span style="font-size: 10pt; color: black;">语言解析成</span><span style="font-size: 10pt; color: black;">RDD</span><span style="font-size: 10pt; color: black;">，再由</span><span style="font-size: 10pt; color: black;">Spark Core</span><span style="font-size: 10pt; color: black;">执行</span></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">     DataFrame</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">是一个分布式集合，其中数据被组织为命名的列。</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: black; font-family: 华文细黑; font-weight: bold;">Dataset</span></font></div><ul><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">是一个新的数据类型。</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">与</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">高度类似，性能比较好。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">不需要反序列化就可执行大部分操作。本质上，数据集表示一个逻辑计划，该计划描述了产生数据所需的计算。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Catalyst</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">优化器。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">与</span> <span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">相似</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">然而</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">并不是使用</span> <span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Java</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">序列化或者</span> <span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Kryo</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;"> </span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">编码器来序列化用于处理或者通过网络进行传输的对象。</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">虽然编码器和标准的序列化都负责将一个对象序列化成字节，编码器是动态生成的代码，并且使用了一种允许</span> <span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">去执行许多像</span> <span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">filtering, sorting</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">以及</span> <span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">hashing</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">这样的操作</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">不需要将字节反序列化成对象的格式。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">jvm</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">中存储的</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">java</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">对象可以是序列化的，也可以是反序列化的。序列化的对象是将对象格式化成二进制流，可以节省内存。反序列化则与序列化相对，是没有进行二进制格式化，正常存储在</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">jvm</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">中的一般对象。</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">可以将序列化的二进制流存储在</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">jvm</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">中，也可以是反序列化的对象存储在</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">JVM</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">中。至于现实使用中是使用哪种方式，则需要视情况而定。例如如果是需要最终存储到磁盘的，就必须用序列化的对象。如果是中间计算的结果，后期还会继续使用这个结果，一般都是用反序列化的对象。</span></div></li></ul><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">DataFrame</span></div><div>    简介： <font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">指定列名称的</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">。</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">是</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset[Row]</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的特例</span></font></div><div><span style="font-family: 华文细黑;">DataFrame是一个由多个列组成的结构化的分布式数据集合，等同于关系数据库中的一张表，或者是R/Python中的data frame。DataFrame是Spark SQL中的最基本的概念，可以通过多种方式创建，例如结构化的数据集、Hive表、外部数据库或者是RDD</span></div><div style="text-align: center;"><span style="font-family: 华文细黑;"><img src="Saprk_files/Image [4].png" type="image/png" data-filename="Image.png" width="377"/></span></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt;"><br/></span></font></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">    </span></font></div><ul><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">提供了详细的结构信息，使得</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">多了数据的结构信息，即</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">schema（纲要）</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">。这里主要对比</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">和</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">，因为</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">和</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">拥有完全相同的成员函数，区别只是每一行的数据类型不同</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">也可以叫</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset[Row],</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">每一行的类型是</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Row</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">getAS</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">方法或者共性中的模式匹配拿出特定字段。而</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">中，每一行是什么类型是不一定的，在自定义了</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">case class</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">之后可以很自由的获得每一行的信息，结合上图总结出，</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">列信息明确，行信息不明确。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: 华文细黑;">由于</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">带有</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">schema</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">信息，因此，查询优化器可以进行有针对性的优化，以提高查询效率。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">在序列化与反序列化时，只需对数据进行序列化，不需要对数据结构进行序列化。</span></div></li><li><div><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Row</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">：代表关系型操作符的输出行；类似</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Mysql</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">的行。</span></div></li></ul><div><span style="font-size: 11pt;"><br/></span></div><div><span style="font-size: 12pt; font-family: 华文细黑; font-weight: bold;">RDD，DataFrame 与Dataset的优缺点</span></div><div><br/></div><div><span style="font-size: 11pt; font-family: 华文细黑;">    RDD（</span><span style="font-size: 11pt; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 11pt; font-family: 华文细黑;">是底层的数据结构</span><span style="font-size: 11pt; font-family: 华文细黑;">）：</span></div><ul><li><div><span style="font-size: 10pt; color: black; font-family: 华文细黑;">优点：类型安全，面向对象。</span></div></li><li><div><span style="font-size: 10pt; color: black; font-family: 华文细黑;">缺点：序列化和反序列化的性能开销大；</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">GC</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的性能开销，频繁的创建和销毁对象</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 10pt; color: black; font-family: 华文细黑;">势必会增加</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">GC（</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">无论是集群间的通信</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 11pt; color: black; font-family: 华文细黑;">还是</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">IO</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">操作都需要对对象的结构和数据进行序列化和反序列化</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">）</span><span style="font-size: 10pt; font-family: 华文细黑;">。</span></div></li></ul><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-family: 华文细黑; font-weight: bold;">DataFrame：</span></font></div><div><span style="font-family: 华文细黑;">        </span></div><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">优点：</span></font></div></li><ol><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">自带</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">scheme</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">信息，降低序列化反序列化开销。</span></font></div></li><li><div><span style="font-size: 10pt;"><span style="font-size: 10pt; font-family: 华文细黑;">off-heap :</span></span> <span style="font-size: 10pt; font-family: 华文细黑;">意味着</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">JVM</span><span style="font-size: 10pt; font-family: 华文细黑;">堆以外的内存</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 10pt; font-family: 华文细黑;">这些内存直接受操作系统管理（而不是</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">JVM</span><span style="font-size: 10pt; font-family: 华文细黑;">）。</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark</span><span style="font-size: 10pt; font-family: 华文细黑;">能够以二进制的形式序列化数据</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">(</span><span style="font-size: 10pt; font-family: 华文细黑;">不包括结构</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">)</span><span style="font-size: 10pt; font-family: 华文细黑;">到</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">off-heap</span><span style="font-size: 10pt; font-family: 华文细黑;">中</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 10pt; font-family: 华文细黑;">当要操作数据时</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">,</span> <span style="font-size: 10pt; font-family: 华文细黑;">就直接操作</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">off-heap</span><span style="font-size: 10pt; font-family: 华文细黑;">内存</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">.</span> <span style="font-size: 10pt; font-family: 华文细黑;">由于</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark</span><span style="font-size: 10pt; font-family: 华文细黑;">理解</span><span style="font-size: 10pt; font-family: &quot;FrutigerNext LT Regular&quot;;">schema,</span> <span style="font-size: 10pt; font-family: 华文细黑;">所以知道该如何操作。</span></div></li></ol><li><div><span style="font-size: 10pt; color: black; font-family: 华文细黑;">缺点：不是面向对象的；编译期不安全。</span></div></li></ul><div>    </div><div><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">    </span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;; font-weight: bold;">Dataset</span><span style="font-size: 12pt; color: black; font-family: 华文细黑; font-weight: bold;">：</span></font></div><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">快：大多数场景下，性能优于</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">；</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Encoders</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">优于</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Kryo</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">或者</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Java</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">序列化；避免不必要的格式转化（</span></font><span style="font-size: 11pt; color: black; font-family: 华文细黑;">快，主要是降低了序列化和反序列化开销，及大量的</span><span style="font-size: 11pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">GC</span><span style="font-size: 11pt; color: black; font-family: 华文细黑;">开销</span><font style="font-size: 10pt;"><span style="font-size: 10pt; font-family: 华文细黑;">）</span><span style="font-size: 10pt; font-family: 华文细黑;">。</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">类型安全：类似于</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">，函数尽可能编译时安全</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">。</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: 华文细黑;">和</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame,RDD</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">互相转化</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">。</span></font></div></li></ul><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Dataset</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">具有</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">RDD</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">和</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">DataFrame</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的优点，又避免它们的缺点</span></font></div><div><br/></div><div>Spark SQL vs Hive（<span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">和</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的语法除了桶表操作外，基本一样</span>）</div><ul><li><div><span style="font-size: 10pt; color: black; font-family: 华文细黑;">区别：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的执行引擎为</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark core</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">，</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">默认执行引擎为</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">MapReduce</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">。</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的执行速度是</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">10-100</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">倍。</span></font></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">不支持</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">buckets</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">，</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">支持。</span></font></div></li></ul><li><div><span style="font-size: 10pt; color: black; font-family: 华文细黑;">联系：</span></div></li><ul><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">依赖</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的元数据。</span></font></div></li><li><div><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark</span> <span style="font-size: 10pt; color: red; font-family: &quot;FrutigerNext LT Regular&quot;;">SQL</span><span style="font-size: 10pt; color: red; font-family: 华文细黑;">兼容绝大部分</span><span style="font-size: 10pt; color: red; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: red; font-family: 华文细黑;">的语法和函数</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">。</span></div></li><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Spark SQL</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">可以使用</span><span style="font-size: 10pt; color: black; font-family: &quot;FrutigerNext LT Regular&quot;;">Hive</span><span style="font-size: 10pt; color: black; font-family: 华文细黑;">的自定义函数。</span></font></div></li></ul></ul><div style="margin: 10px auto; padding: 0px; text-indent: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="text-indent: 0px; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Spark与hadoop:</span></span></div><hr style="margin: 0px; padding: 0px; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><ul style="margin: 0px 0px 0px 30px; padding: 0px; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><li><div><span style="font-size: 13px; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">Hadoop有两个核心模块，分布式存储模块HDFS和分布式计算模块Mapreduce</span></div></li><li><div><span style="font-size: 13px; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">spark本身并没有提供分布式文件系统，因此spark的分析大多依赖于Hadoop的分布式文件系统HDFS</span></div></li><li><div><span style="font-size: 13px; color: rgb(17, 17, 17); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">Hadoop的Mapreduce与spark都可以进行数据计算，而相比于Mapreduce，spark的速度更快并且提供的功能更加丰富</span></div></li></ul><div><span style="color: rgb(17, 17, 17); font-family: Verdana;"><img src="Saprk_files/Image [5].png" type="image/png" data-filename="Image.png" width="365"/></span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(17, 17, 17); font-family: Verdana;"><img src="Saprk_files/Image [6].png" type="image/png" data-filename="Image.png" width="350"/></span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">Spark采用Master和worker的模式，如图3所示。用户在Spark客户端提交应用程序，调度器将Job分解为多个Task发送到各个Worker中执行，各个Worker将计算的结果上报给Driver（即Master），Driver聚合结果返回给客户端。</span></div><div><br/></div><div style="text-align: center;"><span style="color: rgb(17, 17, 17); font-family: Verdana;"><img src="Saprk_files/Image [7].png" type="image/png" data-filename="Image.png" width="328"/></span></div><div style="text-align: center;"><span style="color: rgb(17, 17, 17); font-family: Verdana;">图3 Spark的Master和Worker  </span></div><div style="text-align: center;"></div><div><br/></div><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">在此结构中，有几个说明点：</span></div><ul><li><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">应用之间是独立的。</span></div></li><li><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">每个应用有自己的executor进程，Executor启动多个线程，并行地执行任务。无论是在调度方面，或者是executor方面。各个Driver独立调度自己的任务；不同的应用任务运行在不同的JVM上，即不同的Executor。</span></div></li><li><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">不同Spark应用之间是不共享数据的，除非把数据存储在外部的存储系统上（比如HDFS）。</span></div></li><li><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">因为Driver程序在集群上调度任务，所以Driver程序最好和worker节点比较近，比如在一个相同的局部网络内。</span></div></li></ul><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">Spark on yarn有两种部署模式。</span></div><ul><li><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">yarn-cluster模式下，Spark的Driver会运行在YARN集群内的ApplicationMaster进程中，ApplicationMaster已经启动之后，提交任务的客户端退出也不会影响任务的运行。</span></div></li><li><div><span style="color: rgb(17, 17, 17); font-family: Verdana;">yarn-client模式下，Driver启动在客户端进程内，ApplicationMaster进程只用来向YARN集群申请资源</span></div></li></ul><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Spark  Sreaming</span></font></div><div><br/></div></div><div>        是Spark上的实时计算框架，扩展大规模流式处理能力</div><div><br/></div><div><br/></div><div>在一个Spark Streaming应用开始时（也就是driver开始时），相关的StreamingContext（所有流功能的基础）使用SparkContext启动Receiver成为长驻运行任务。这些Receiver接收并保存流数据到Spark内存中以供处理。用户传送数据的生命周期如图4所示：</div><div style="text-align: center;"><img src="Saprk_files/Image [8].png" type="image/png" data-filename="Image.png" width="486"/></div><div style="text-align: center;">图4 数据传输生命周期</div><div>1.接收数据（蓝色箭头）</div><div>    Receiver将数据流分成一系列小块，存储到Executor内存中。另外，在启用WAL以后，数据同时还写入到容错文件系统的预写日志中。</div><div>2.通知Driver（绿色箭头）</div><div>    接收块中的元数据（metadata）被发送到Driver的StreamingContext。这个元数据包括：</div><div>        定位其在executor内存中数据位置的块reference id。</div><div>        块数据在日志中的偏移信息（如果启用了WAL，即预写日志功能）。</div><div>3.处理数据（红色箭头）</div><div>    对每个批次的数据，StreamingContext使用Block信息产生RDD及其Job。StreamingContext通过运行任务处理Executor内存中的Block来执行Job。</div><div>4.周期性地设置检查点（橙色箭头）</div><div>5.为了容错的需要，StreamingContext会周期性地设置检查点，并保存到外部文件系统中。</div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">容错性</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">恢复流程</span></div><div><br/></div><div><br/></div><div>1.恢复计算（橙色箭头）</div><div>    使用checkpoint信息重启Driver，重新构造SparkContext并重启Receiver。</div><div>2.恢复元数据块（绿色箭头）</div><div>    为了保证能够继续下去所必备的全部元数据块都被恢复。</div><div>3.未完成作业的重新形成（红色箭头）</div><div>    由于失败而没有处理完成的批处理，将使用恢复的元数据再次产生RDD和对应的作业。</div><div>4.读取保存在日志中的块数据（蓝色箭头）</div><div>    在这些作业执行时，块数据直接从预写日志中读出。这将恢复在日志中可靠地保存的所有必要数据。</div><div>5.重发尚未确认的数据（紫色箭头）</div><div>    失败时没有保存到日志中的缓存数据将由数据源再次发送。因为Receiver尚未对其确认。</div><div>    因此通过预写日志和可靠的Receiver，Spark Streaming就可以保证没有输入数据会由于Driver的失败   <span style="font-size: 12pt; font-weight: bold;"> </span><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 10pt;">而丢失。</span></div><div><span style="font-size: 12pt; font-weight: bold;">RDD</span></div><div>        即弹性分布数据集（Resilient Distributed Dataset），是Spark的核心概念。指的是一个只读的，可分区的分布式数据集，这个数据集的全部或部分可以缓存在内存中，在多次计算间重用。</div><div>RDD的生成：</div><ul><li><div>从HDFS输入创建，或从与Hadoop兼容的其他存储系统中输入创建。</div></li><li><div>从父RDD转换得到新RDD。</div></li><li><div>从数据集合转换而来，通过编码实现。</div></li></ul><div>RDD的存储：</div><ul><li><div>用户可以选择不同的存储级别缓存RDD以便重用（RDD有11种存储级别）。</div></li><li><div>当前RDD默认是存储于内存，但当内存不足时，RDD会溢出到磁盘中。</div></li></ul><div>Dependency（RDD的依赖）</div><div>    RDD的依赖分别为：窄依赖和宽依赖。</div><div><span style="font-size: 12pt;"><br/></span></div></div><div><br/></div></span>
</div>
<a href="../index.html">返回首页</a>
</body></html> 